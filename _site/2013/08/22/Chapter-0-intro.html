<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Urbit - Chapter 0 &#58; Introduction and philosophy</title>
  <meta name="author" content="Urbit" />
  <meta name="description" content="The blog of Urbit" />
  <link rel="canonical" href="http://example.com/2013/08/22/Chapter-0-intro.html" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Urbit" href="http://example.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
<!--[if IE 7]>
  <link rel="stylesheet" href="/assets/css/font-awesome-ie7.min.css">
<![endif]-->
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.svg" id="logo" alt="logo"/>
  </a>
  <h2> Urbit</h2>
  <hr/>
  <ul>
  <p>An operating function</p>
  <p>
   <a href="/">Documentation </a>
   <br>
   <a href="/">FAQ</a>
   <br/>
   <a href="/">Community</a>
  </p>
  <hr/>
  <div>
    <div id="social">
      Follow:
<div id="stalker">
  
  <a title="urbit on Github" href="http://github.com/urbit">
    <i class="icon-github-sign"></i>
  </a>
  

  
  <a title="urbit on Hacker News" href="http://news.ycombinator.com/user?id=urbit">
    <i class="icon-sign-blank"></i>
    <span class="icon-overlay icon-hn">Y</span>
  </a>
  
  
  <a title="Urbit1 on Twitter" href="http://twitter.com/Urbit1">
    <i class="icon-twitter-sign"></i>
  </a>
  
  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="icon-rss-sign"></i>
  </a>
</div>

    </div>
  </div>
  </ul>
</nav>

    </div>

    <div class="eleven columns content">
      <p class="meta">
  <a href="/">
    <i class="home icon-home"></i>
  </a>
</p>

<h1 class="title">Chapter 0 &#58; Introduction and philosophy</h1>

<div id="post">
  <p>Urbit is a new programming and execution environment designed from scratch. Any resemblance to existing languages or operating systems is coincidental, cosmetic, or inevitable.</p>

<h2 id='urbit_is_a_stack'>Urbit is a stack</h2>

<p>Nock is a stateless virtual machine defined in 200 words. The Nock machine is sealed - all execution is &#8220;pure.&#8221; Nock&#8217;s goal is extreme commoditization of computing semantics.</p>

<p>Hoon is a high-level language which defines itself in Nock. Its self-compiling kernel, 7000 lines of code, specifies Hoon unambiguously; there is no Hoon spec. Hoon can be classified as a pure, strict higher-order static type-inferred functional language, with co/contra/bivariance and genericity. However, Hoon does not use lambda calculus, unification, or other constructs from &#8220;PL theory.&#8221; Hoon also excels at handling and validating untyped data, a common task on teh Internets. Its syntax is entirely novel and initially quite frightening.</p>

<p>Arvo is a deterministic functional operating system defined in Hoon. While still basically a toy, it can serve web apps and network securely with other Arvo instances. An Arvo instance is designed to be a simple independent computer in the cloud.</p>

<p>It&#8217;s possible to use Nock without Hoon, but there is no obvious reason to do so. It&#8217;s not necessary to learn Nock to learn Hoon, but it helps a lot. The same for Hoon and Arvo. Therefore, we&#8217;ll work through all three in order. in order. If you&#8217;re convinced that you want to learn Urbit, feel free to skip the justifications below.</p>

<h2 id='nock'>Nock</h2>

<p>Nock is a virtual machine, like the Java VM or Microsoft CLR. Just as you execute Java by compiling it to the JVM, you execute Hoon by compiling it to Nock.</p>

<p>Do you need to learn Nock to learn Hoon? In theory, no, just as you don&#8217;t need to know anything about the JVM to learn Java. Indeed, in theory we could compile Hoon to the JVM (or Java to Nock). What&#8217;s the difference between Nock and the JVM, anyway? Why do we need a new virtual machine? And since we&#8217;ll only be programming in Hoon, why do we care how Hoon is executed?</p>

<p>There is no formal difference between Nock and the JVM. In theory, both are Turing-complete computers. In practice, they have just about nothing in common.</p>

<p>The main practical difference is that Nock is two orders of magnitude simpler. The JVM spec is a book. The Nock spec is 200 words; it fits on a T-shirt; it gzips to 371 bytes. There are lots of other differences, but all follow from this.</p>

<p>Why does size matter? The goal of any programming language is to become a standard. Universal standardization equals world domination. The simpler a specification is, the easier to standardize. Nock is a practical interpreter as simple as the most frozen and fundamental of protocols or formats: IPv4, XML, JSON. A 200-word spec needs a standards process like a fish needs swim lessons. When a T-shirt goes to war with a book, it&#8217;s like tanks against cavalry - or should be, anyway.</p>

<p>Since every program in Hoon (including the Hoon compiler) reduces to Nock, every program in Hoon inherits Nock&#8217;s precision. If two Nock interpreters produce different results, one is wrong, and it is always easy to tell which - without a &#8220;standards lawyer.&#8221; Can we imagine the end of incompatiblity?</p>

<p>Essential to actually realizing this promise is a second difference between Nock and the JVM, which is that the JVM can call Unix system calls and libraries, and Nock can&#8217;t. Nock has no &#8220;native methods&#8221; or foreign-function interface. Nor is it ever extended, embellished, forked, improved or advanced.</p>

<p>Java began as a portable language; so did C. Most Java today is server-side Java, dependent no less than C on library and OS configuration. It is possible to write portable Java; it is possible to write portable C. It is not possible to write unportable Nock or Hoon. It is also not possible to write insecure Nock or Hoon, unless your interpreter is so broken there&#8217;s an actual hole in its skull.</p>

<p>How does Nock obtain native CPU performance, if it can&#8217;t call native code? This is actually a much more pressing problem in Nock than in conventional virtual machines, like the JVM, because naive Nock is hopelessly inefficient. Nock is defined in a page of pseudocode, and a naive interpreter can be written in a page of any language. But since Nock&#8217;s only arithmetic operator is increment, decrement in your one-page interpreter is an <code>O(n)</code> operation. Addition is <code>O(n^2)</code>. And so on.</p>

<p>The programmer cannot solve this problem by calling a C function, because Nock can&#8217;t do that. In theory, an optimizing Nock interpreter might be able to analyze the code and reduce it to a simpler equivalent. But this would be a true research problem.</p>

<p>Instead, a practical Nock engine simply recognizes code it knows and substitutes equivalent C functions, or &#8220;jets.&#8221; For instance, in theory there are many different ways to express decrement in Nock, but in practice the Nock interpreter will execute only one: the decrement function in the Hoon kernel. Therefore, the only Nock decrement that must be optimized is the code that Hoon generates when it compiles its own decrement. All others will suck, so don&#8217;t roll your own. Code recognition, as opposed to code analysis, is not a research problem.</p>

<p>Jet propulsion separates mechanism and policy, transferring the task of achieving native performance from the programmer to the sysadmin. The Hoon programmer must still use hints to mark functions for jet recognition, but cannot control or discern how these functions are actually executed. Of course, a correct jet is indistiguishable in every way, except timing, from naive Nock. The 200-word spec defines the result, not the algorithm.</p>

<p>We can see a jet as a sort of &#8220;functional device driver.&#8221; For instance, an OpenGL programmer today has no idea whether her GL operations are implemented in software or by a GPU. This abstraction is essential to modern graphics programming.</p>

<p>When we compare jets to native calls, what are the pros and cons? Jets have only one disadvantage: high-performance code must be written twice, once in Hoon and once in C. Indeed, from the C programmer&#8217;s perspective, Hoon is a specification language for your C functions. Hoon specifications are executable, of course, so you can test the two implementations against each other - again, transparently to the programmer. Moreover, the jet can even fail in special cases and drop back to the interpreter.</p>

<p>Hoon ships with a Nock that jet-propels most of the Hoon kernel, including most of the Hoon compiler. If you&#8217;re wondering how we wrote Hoon in Hoon when we didn&#8217;t have Hoon, the answer is that we wrote Hoon in C and evolved this C code into a mere jet. This process is not recommended unless absolutely necessary - by far the best way to write the jet pair is to write the Hoon first.</p>

<h2 id='hoon'>Hoon</h2>

<p>If I can summarize Hoon&#8217;s goal, it&#8217;s to be the C of functional programming. If you&#8217;re not so arthritic that you learned to code in Turbo Pascal, you may never fully appreciate the metaphor.</p>

<p>All languages in the Algol procedural family, including both C and Pascal, map straightforwardly onto a conventional CPU. But Pascal and C handle this mapping very differently. Pascal and C both have pointers and arrays, but Pascal works hard to treat both pointers and arrays as mathematical abstractions. C drops the abstraction; it makes no bones about the fact that a pointer is a memory address.</p>

<p>To a Pascal purist, to anyone who thinks mathematically, this seemed hideous. C isn&#8217;t really a high-level language at all - it&#8217;s a glorified macro assembler. Mankind retreats to the cave. But to programmers who are not natural mathematicians, whose minds are mechanical rather than abstract, C is a lifesaver. Since most mathematicians are also good mechanical thinkers, whereas very few people are naturally adept at abstraction, C slew and pillaged the once promising empire of Pascal.</p>

<p>There are two broad families of functional language available today: Haskell/ML, and Lisp. The Haskell family is relatively abstract; the Lisp family, relatively concrete. Perhaps Lisp is about as abstract as Pascal; Haskell is far more abstract. Both rest on the fundamental abstraction of functional programming, the lambda calculus, and more generally the foundational metamathematics of the late 19th and early 20th centuries.</p>

<p>Hoon has nothing to do with any of this stuff. It has functions and types, or what appear to be functions and types. On closer inspection, they are not abstractions at all, just glorified Nock macros.</p>

<p>If we compare these concrete patterns to the genuine abstractions of Haskell, we see that - as with Pascal and C - Hoon is roughly as expressive as Haskell. Haskell has higher-order type inference; Hoon has &#8220;higher-order&#8221; &#8220;type&#8221; &#8220;inference.&#8221; Some Haskell extensions have dependent types - Hoon has &#8220;refined&#8221; &#8220;types.&#8221; Hoon, like Lisp, unlike Haskell, is also very comfortable with typeless data; it should be, because it has no types, only &#8220;types.&#8221; The Hoon features and the Haskell abstractions have nothing in common - except that they solve the same problems for you, the programmer. In short, Hoon next to Haskell is a white shark next to a killer whale. The apparent resemblance is strictly superficial.</p>

<p>So we could describe Hoon as a pure, strict, higher-order typed functional language. But don&#8217;t do this in front of a Haskell purist, unless you put quotes around &#8220;typed,&#8221; &#8220;functional,&#8221; and possibly even &#8220;language.&#8221; We could also say &#8220;object-oriented,&#8221; with the same scare quotes for the cult of Eiffel.</p>

<p>Knowing Pascal made it harder, not easier, to learn C. Knowing Haskell or Lisp makes it harder to learn Hoon. Indeed, knowing either would have made it impossible for me to write Hoon. I do know C, of course, and the spirit of K&amp;R is all over Hoon. Or so I&#8217;d like to think. Just as C is little more than a macro assembler for machine code, Hoon is little more than a macro assembler for Nock.</p>

<p>The most basic difference between Hoon and other languages is that Hoon is defined in Hoon. There is no formal Hoon spec - just a self-compiling compiler written in Hoon. The target of this compiler is, of course, Nock. Thus Hoon is as precisely defined as Nock, which is quite precisely indeed.</p>

<p>This would be true regardless of the size of Hoon in Hoon, but Hoon in Hoon is in fact quite small. The Hoon kernel is 7000 lines; it gzips to 25K. But this includes not only the self-compiling compiler, but also all the standard libraries it needs. The compiler alone is 2500 lines, including a very intricate &#8220;monadic&#8221; parser, a non-Hindley-Milner &#8220;type inference&#8221; engine, and a Nock code generator. This reflects both the internal simplicity of Hoon and its expressiveness. If you know these 2500 lines, and an expert should, you <em>know</em> Hoon.</p>

<p>On the other hand, the <em>apparent</em> complexity of Hoon is very high. When you open a Hoon file, you are confronted with an enormous avalanche of barely structured line noise. Again this reminds us of C, which makes no attempt at the kind of abstract prettiness we expect from a Pascal or a Haskell. Learning Hoon involves learning nearly 100 ASCII digraph &#8220;runes.&#8221;</p>

<p>Is this a harsh learning curve? Of course it is. On the other hand, it is not a mathematical task, but a mechanical one. It is trivial compared to the task of learning the Chinese alphabet, memorizing the Qu&#8217;ran, etc, all rote mental tasks routinely performed by normal human 11-year-olds. If you have an 11-year-old who understands the Hindley-Milner algorithm, you have a remarkable young mathematician.</p>

<p>A practical programming language is first and foremost a UI for programmers - meaning human programmers. Concrete languages beat abstract ones because they play to the strengths of the human brain, and avoid its weaknesses. Functional programming is traditionally reserved for the topmost echelon of natural talent. I&#8217;d like to think that anyone who can learn to fix a Chevy can learn to write a Hoon function. We&#8217;ll see if that&#8217;s true.</p>

<p>A programming language is called a language for a reason - it should activate the human linguistic lobes. Learning Hoon is like learning a language very alien to your first, such as Chinese from English. Before you know Hoon, it looks like squiggles. Once you know Hoon, and the rote task of syntax processing is hardwired, you look at your screen and <em>see</em> the function. Or, at least, I do - I hope you can too.</p>

<h2 id='arvo'>Arvo</h2>

<p>Lorem ipsum.</p>
</div>


    
      <div class="footer">
        <div class="disclaimer">
  

  <p>
    © Urbit, 2013 &mdash; built with Jekyll using Lagom theme
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-xxxx-x']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>