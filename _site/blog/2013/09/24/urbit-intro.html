<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Urbit - Welcome to Urbit</title>
  <meta name="author" content="Urbit" />
  <meta name="description" content="The blog of Urbit" />
  <link rel="canonical" href="http://example.com/blog/2013/09/24/urbit-intro.html" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Urbit" href="http://example.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
<!--[if IE 7]>
  <link rel="stylesheet" href="/assets/css/font-awesome-ie7.min.css">
<![endif]-->
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.svg" id="logo" alt="logo"/>
  </a>
  <h2> Urbit</h2>
  <hr/>
  <ul>
  <p>An operating function</p>
  <p>
   <a href="/">Documentation </a>
   <br>
   <a href="/faq.html">FAQ</a>
   <br/>
   <a href="/blog.html">Blog</a>
   <br>
   <a href="/community.html">Community</a>
  </p>
  <hr/>
  <div>
    <div id="social">
      Follow:
<div id="stalker">
  
  <a title="urbit on Github" href="http://github.com/urbit">
    <i class="icon-github-sign"></i>
  </a>
  

  
  <a title="urbit on Hacker News" href="http://news.ycombinator.com/user?id=urbit">
    <i class="icon-sign-blank"></i>
    <span class="icon-overlay icon-hn">Y</span>
  </a>
  
  
  <a title="Urbit_ on Twitter" href="http://twitter.com/Urbit_">
    <i class="icon-twitter-sign"></i>
  </a>
  
  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="icon-rss-sign"></i>
  </a>
</div>

    </div>
  </div>
  </ul>
</nav>

    </div>

    <div class="eleven columns content">
      <p class="meta">
  <a href="/">
    <i class="home icon-home"></i>
  </a>
</p>

<h1 class="title">Welcome to Urbit</h1>

<div id="post">
  <p>But wait - what the hell is Urbit?</p>

<p>One of Urbit&#8217;s problems is that we don&#8217;t exactly have a word for what Urbit is. If there is such a word, it somehow means both &#8220;operating system&#8221; and &#8220;network protocol,&#8221; while somehow also implying &#8220;functional&#8221; and &#8220;deterministic.&#8221;</p>

<p>Not only is there no such word, it&#8217;s not even clear there <em>should</em> be one. And if there was, could we even hear it? As Wittgenstein said: if a lion could talk, we would not understand him. But heck, let&#8217;s try anyway.</p>

<p>As a network protocol, we could call Urbit a &#8220;seven-layer protocol&#8221; - that is, a protocol that specifies the complete semantics of the general-purpose computer that processes it. As any decent IETF ninja will tell you, this is a very bad idea for all sorts of extremely obvious reasons.</p>

<p>And from the OS perspective, Urbit is yet another slice of userspace crap with the temerity to call itself an &#8220;operating system.&#8221; Urbit is not actually an OS in the bare-metal sense. It&#8217;s a VM that runs on Linux or OS X. Someday it might be so daring as to descend to Xen. Urbit has no interest at all in drivers, peripherals, etc. It is just a UDP transceiver in the cloud. Worst of all - Urbit is not even preemptive. A poser! (Actually all the real work, as in node, is done by libuv.)</p>

<p>Moreover, this VM is formally isolated from your actual OS. And everything that uses it. Nothing in Urbit can request system services or call existing libraries. So Urbit is not only badly designed and fraudulently hyped. It&#8217;s also profoundly useless.</p>

<p>Well&#8230; your browser has been reasonably successful with this restriction. But your browser was never designed to be any kind of OS. To the extent that it&#8217;s sort of become an OS, it is specialized for the very undemanding job of being a client. A general-purpose client, which is neat. But not a general-purpose server - which is a much harder problem.</p>

<p>A general-purpose server is a slab of code that feels totally confident when faced with the problem of storing <em>all your personal and/or corporate data</em>, across <em>arbitrary functional upgrades</em>, for <em>all time forever</em>, while efficiently executing and managing <em>any useful program or programs, transient or persistent</em>. Yeah, that&#8217;s a server OS.</p>

<p>So, conventionally, this industrial strength slab of code is written with conventional OS techniques involving (a) bare metal and (b) like, semaphores and shit. The kernel alone is like 12 million lines of code. Not that a browser is any much smaller.</p>

<p>And so, 20th-century network computing is the world&#8217;s most beautiful wire, between two dumpsters of shit spaghetti. Two <em>completely different</em> dumpsters. It turns out that with a big enough dumpster of shit spaghetti, you can feed the world. And why not two? Incompatibility creates jobs, you know.</p>

<p>Oh, and you can have a client without an identity. But you can&#8217;t have a <em>server</em> without an identity. So Urbit has to solve <em>that</em> problem. Unless it&#8217;s just going to be a Web server. (Urbit is actually a perfectly decent Web server.) Unless it has an actual identity model, your general-purpose server - presumably a <em>network</em> server - has no network effect. No identity, no network. No network, who the hell cares?</p>

<p>And unlike your ordinary, common or garden Web application server, Urbit does need that network effect. You see, it&#8217;s not even our own work. It&#8217;s something we found. On an unmarked USB stick by the side of the road three kilometers from Area 51.</p>

<p>We think it&#8217;s probably still human engineering. First of all, there are no aliens. Second, Urbit uses Unicode. Do the aliens have Unicode? Or SHA-256? <em>Where did Unicode come from, anyway?</em> And at the I/O level, we see UDP, HTTP, etc. The command line does Emacs keys. At the very least, someone on Earth (or at least <em>from</em> Earth) has done some porting.</p>

<p>But other than these cosmetic details, there&#8217;s not much sign of a connection to ordinary Earth computing. For instance, Urbit isn&#8217;t written in any of our Earth languages. It is written in something called Hoon, which is a strict, higher-order, typed functional language - but has nothing in else in common with other Earth languages, functional or not. Hoon does not even use standard PL theory. And its syntax is just as alien, although at least it confines itself to the ASCII plane. (And you probably thought the &#8220;A&#8221; in &#8220;ASCII&#8221; stood for &#8220;American.&#8221;)</p>

<p>Worse yet, Hoon is not written in anything normal. It&#8217;s written in Hoon. To be precise - the Hoon compiler compiles itself to a much simpler automaton, Nock. Besides machine language itself, and its various bytecode homages, there are three simple formal models of computing - Turing machines, lambda calculus, and Chuck Moore. There is also a fourth which no one has ever found useful for anything: combinators. Nock is a combinator automaton.</p>

<p>While nowhere near the simplest such automaton known, and certainly not of any <em>theoretical</em> interest, Nock is so stupid that if you gzip the spec, it&#8217;s only 374 bytes. Nock&#8217;s only arithmetic operation is increment. So decrement is an <code>O(n)</code>, operation; add is <code>O(m*n)</code>&#8230;</p>

<p>Clearly not a practical system. Even if this&#8230; <em>thing</em>&#8230; that sits on top of it was in any way, shape or form remotely sane.</p>

<p>So why not try it? Heck, why not at least check it out? Strange and foolish dreamers may hie themselves to teh github:</p>

<p><a href='https://github.com/urbit'>https://github.com/urbit</a></p>

<p>Various people have built and run Urbit on Ubuntu, Homebrew and MacPorts. It&#8217;s possible that all these people were stone cold ninjas. Urbit is a pretty cool toy, I think, if you&#8217;re a ninja. Unfortunately it is not really ready for ordinary rice farmers. If you can&#8217;t resolve build dependencies by hand, we&#8217;re sorry. Urbit is probably not yet ready for you.</p>

<p>Where should you run Urbit? Ideally, in the cloud. Urbit can punch a decent NAT hole. It doesn&#8217;t like to, though - what does? Bear in mind that your Urbit instance is a single-level store - your state is saved as a log and a checkpoint (as in Redis - except that Redis is both fast and reliable). This will work much better on server hardware. That said, there are plenty of good reasons to keep your servers in the closet with the plants.</p>

<p>Next, you need a ticket. Or not. You at least need to decide whether you want a ticket or not. Actually, the answer is simple. You do want one. But you don&#8217;t need one - not yet.</p>

<p>Because Urbit, the OS, never depends on Earth semantics, it needs its own network protocol - Ames. Ames is a P2P protocol with its own public-key infrastructure. (Ames is encrypted, but the current cryptosuite, suite A, is worthless snakeoil. Don&#8217;t trust it with your Trader Joe receipts.) Ames runs over UDP, and pays as little attention to IP routing as possible. Needless to say, Urbit does not use the DNS at all.</p>

<p>To sling packets on Ames, you need an identity. Needless to say, there are a lot of ways to do distributed cryptographic identity, all of them bad.</p>

<p>The general reason all PKIs suck is called &#8220;Zooko&#8217;s Triangle.&#8221; Your identities can be distributed, secure, or human-meaningful - pick any two. There is no way to solve Zooko&#8217;s Triangle. The only way to attack it is to compromise on at least one vertex.</p>

<p>To see how Urbit works, let&#8217;s start with a standard solution. An Urbit identity is called a &#8220;ship.&#8221; You can launch your own ship by generating a 2048-bit RSA key and hashing it to a 128-bit fingerprint, which is your identity. This trivial design is the basis of all distributed, secure PKIs.</p>

<p>Unfortunately, an identity should be above all a <em>name</em>. A 128-bit fingerprint looks like this:</p>

<p>which isn&#8217;t a name. For no better reason than the fact that, unless you&#8217;re an autistic savant, you are basically a monkey with an overgrown monkey brain. A name is something that fits in a register. Your monkey brain doesn&#8217;t have 128-bit registers.</p>

<p>Suppose we could use 64-bit fingerprints? At first this seems even less promising. First of all, your monkey brain doesn&#8217;t have 64-bit registers, either. Second, at 64 bits, collisions are already a real problem.</p>

<p>But we can solve both these problems. Your monkey brain doesn&#8217;t have 64-bit registers. But anything that lets us do 64-bit identities might stretch down to 32 bits. And at 64 or 32 bits, we can&#8217;t assign identities by random hash. So we&#8217;ll have to find another way of distributing them.</p>

<p>A 32-bit identity - or even a 16-bit identity - will still never be human-meaningful. Perhaps we can make it human-memorable. Meaningful addresses are a nice feature in a social network, but memorable addresses are essential. And if we have memorable addresses, perhaps we can build meaningful names on top.</p>

<p>The classic example of a memorable address is a street address. Your street address identifies you precisely, using a name. You have this great brain hardware for remembering names. But what does the name of your street <em>mean</em>? Nothing at all, usually. And even if it does mean something, by accident or design, that meaning has nothing at all to do with you. (One of us grew up in Columbia, Maryland, which has street names like &#8220;Greek Boy Place.&#8221;)</p>

<p>So all we need is a simple, tasteful, memorable way to remember 32 bits - and we&#8217;re on our way to approximating the Triangle.</p>

<p>Decimal notation is the worst way of remembering a 32-bit number. IP notation is a little better. Urbit has a typically crude approach: we map every byte to a CVC phoneme, making names like:</p>

<pre><code>   ~tasfyn-partyv
   ~sivbud-barnel
   ~tomsyt-balsen</code></pre>

<p>These strings, while quite meaningless, are no less memorable than real human names in many a language. Moreover, they form a language of their own, and become more memorable as you use them. And there are 4 billion of them, which (as we&#8217;ll see) is almost exactly the right number.</p>

<p>But how do we distribute them? One obvious solution is a proof of work scheme, as in Bitcoin. Coordinating a global proof-of-work scheme is quite nontrivial, however. Also, there is a second reason to compromise 100% decentralization: packet routing. It might be possible to use a blockchain as a global routing table. It would take some thinking about.</p>

<p>Furthermore, there&#8217;s a clue here that the Bitcoin approach just isn&#8217;t getting. The limited subspace of short names, within the general space of 128-bit names, is essentially <em>real estate</em>. There is absolutely no reason, moral or practical, to give this real estate away for free to people whose only contribution is generating CO2 on their GPUs. Mining is not in any way a productive activity.</p>

<p>Rather, initially, this real estate belongs to Urbit itself. If Urbit has value, its real estate has value. If Urbit has no value, its so-called real estate is a bunch of worthless bits. Therefore, any value in the real estate can, should, and will be used to bootstrap the system from an economic perspective. Ie, it belongs to and will be captured by Urbit&#8217;s developers and/or early adopters. If you find this morally wrong, sorry. You&#8217;re probably some kind of a communist.</p>

<p>But because Urbit is a free republican society - not (ahem) a fascist corporate dictatorship like Google, Facebook or Twitter - a crucial aspect of launching or transferring a ship is that the decision is irreversible.</p>

<p>As the master of an Urbit ship, your informal title is cryptographic and <em>allodial</em> - no one, not the government and certainly not us, can challenge it. Unless the attacker can steal your secrets. In which case, of course, she might as well be you. That&#8217;s like Bitcoin too.</p>

<p>If Bitcoin is money, Urbit is land. (Floating land is still land, if there&#8217;s a limited amount of it.) You own both in the same way, by proving you can keep a secret. A Bitcoin is not useful for anything, except selling to a greater fool. (We&#8217;re just kidding - we&#8217;re huge Bitcoin fans.) But an Urbit ship is directly useful, so long as Urbit itself is useful.</p>

<p>You fill your Bitcoin wallet either by creating new coins, or buying old ones from Satoshi and his cronies. You build your Urbit fleet by buying ships from us and our cronies. (Don&#8217;t ask what we had to do to get them from the aliens. Those aliens are into a lot of strange shit, man.) Ships are transferable, but Urbit is not designed to be a digital currency. Transaction overhead is artificially high. Again, as in real estate.</p>

<p>Urbit at present is empty and worthless. So 32-bit ships - destroyers - are $0. Launch a 128-bit ship (a submarine) and ask me, ~tasfyn-partyv, for one. We&#8217;ll send you one, two, or a dozen. You can be as anonymous as you want, if you&#8217;re polite. But, if the network lives, a destroyer price will develop. It will be very low at first, but not zero. Urbit is designed to be free as in speech. It&#8217;s not designed to be free as in beer.</p>

<p>How, cryptographically, are cloud ships distributed? And how are packets routed? The answer is the same - the prefix hierarchy.</p>

<p>In Urbit&#8217;s naval terminology, ships above 64 bits are &#8220;submarines.&#8221; 64-bit ships are &#8220;yachts.&#8221; 32-bit, &#8220;destroyers.&#8221; 16-bit, &#8220;cruisers.&#8221; 8-bit, &#8220;carriers.&#8221; This also resembles a feudal hierarchy, so it comes with a feudal terminology. There are 256 imperial carriers, 65.280 royal cruisers, 4.294.901.760 rebel destroyers, uncounted scads of private yachts, and more or less infinitely many rogue submarines.</p>

<p>Every ship but a submarine has a &#8220;will,&#8221; or certificate chain - a linked list of &#8220;deeds.&#8221; The first deed in this list is signed by the ship&#8217;s hierarchical prefix, or &#8220;flagship.&#8221; Mere submarine are independent; carriers create cruisers; cruisers create destroyers; destroyers create yachts.</p>

<p>A submarine is the fingerprint of its own private key; a carrier&#8217;s fingerprint is predefined in the kernel. Anyone can create any number of 128-bit submarines, whose free and independent society the 64-bit naval hierarchy cannot interfere with. And of course, since Urbit is (a) in the public domain and (b) not patented, anyone can fork Urbit and change the carrier fingerprints. Anyone can also create his own independent and incompatible DNS, but efforts in this direction have not been crowned with great success. In general, the easier it is technically to fork open-source code or an open standard, the less likely a fork is to actually happen.</p>

<p>An independent ship is an independent reputation. Your flagship hierarchy, though it created your ship, has no control over it - so your reputations are and should be separate. But there are not 2^64 independent reputations in Urbit, only 2^32. Cruisers have no control over the destroyers they create, but yachts have no independence from the destroyers that created them.</p>

<p>The reason for this is simple - a destroyer corresponds not to a person, but to any institution with its own independent reputation. Yachts are for users, bots, or other sub-identities of this institution. Each destroyer has 2^32 of them, which is, of course, a lot.</p>

<p>How does independence work in practice? By pinning/TOFU. For any deed number, or &#8220;life,&#8221; the first instance is accepted. Thus when changing secrets, perhaps to transfer a ship, the donor signs a new deed created by the recipient. Once any ship sees this deed, it will never accept another signed by the old owner. Thus, a cruiser cannot sell the same new destroyer twice. Similarly, deed 7 of ~tasfyn-partyv signs deed 8; but no ship which has a deed 8 for ~tasfyn-partyv will either accept deed 7, or any other purported deed 8 which deed 7 later signs.</p>

<p>Preventing a &#8220;double spend&#8221; thus depends on propagating the latest deed. For this purpose, the ocean is divided into two kinds of ships: friends and non-friends of the ship being transferred. The ship has a list of its cryptographic partners, or &#8220;neighbors,&#8221; for which it holds a symmetric key and a routing (IP) address.</p>

<p>The new owner sends the new deed to all the neighbors, thus locking the old owner out of them. Future new friends will get the new owner&#8217;s will the same way they get the new owner&#8217;s IP address - by a lookup through the flagship hierarchy. Thus if we update both neighbors and flagship, the old owner is locked out and the new owner is locked in.</p>

<p>Technically, this is very much an imperfect procedure. It relies on social trust to make it effective. For example, a malicious seller could edit his neighbor list before delivering the ship. You probably don&#8217;t want to buy a used destroyer from someone you distrust. Of course, the same is true of cars.</p>

<p>And more broadly, the naval hierarchy can and should provide general administrative support. For one thing, the big ships route your packets, at least when establishing contact with your fellow destroyers.</p>

<p>So - do you want an Urbit destroyer? You know you do. Moreover, they&#8217;re free. Of course, if you are satisfied with a name that looks like</p>

<pre><code>    ~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted</code></pre>

<p>you can keep swimming around Urbit in your submarine.</p>

<p>For a while, anyway. Because, besides memorability, there is another reason for short names.</p>

<p>What&#8217;s neat about short names is that there&#8217;s a finite number of them. This is not a bug, but a feature. Essentially, to borrow the thinking of political scientist James Scott, a finite space is <em>governable</em>. An infinite space is ungovernable.</p>

<p>If there are an infinite number of identities, there is no way for anyone to distinguish between a new user and a banned user. A reputation can be punished by destroying it, but anyone can start again at zero. A parasite whose only reason to use the network is to abuse it can keep coming back for more. An email spammer will never run out of addresses to spam from.</p>

<p>IPv4 is a limited space, which almost but doesn&#8217;t cure spam. The problem is that IPv4 addresses are neither personal nor property, so there is generally no easy way to punish a spammer as he deserves through IP blacklisting. He is very unlikely to be in any sense the owner of the IP address on his packets.</p>

<p>But if the email address and the IP address were the same thing, and the present fuzzy economic relationship between the user of an IP address were clear and simple, killing spam would become easy. You spam from a destroyer; you go on a list of spammers; no one will accept your unsolicited messages, ever.</p>

<p>You can get around this. You can buy a new destroyer. But the thing is - it costs you <em>money</em>. You&#8217;re not spamming for the fun of it. If a destroyer costs a mere $1, the spam you send from it needs to earn you $1.</p>

<p>This does not make it trivial for the forces of light to hunt you down and render you into processed meat clippings. But it sure as heck evens the game. Who will win? I guess we&#8217;ll see.</p>

<p>So do you want an Urbit destroyer? Read the <a href='/doc/2013/08/22/Chapter-1-arvo.html'>documentation</a> for instructions. Come on, they&#8217;re free&#8230;</p>
</div>


    
      <div class="footer">
        <div class="disclaimer">
  

  <p>
    © Urbit, 2013 &mdash; built with Jekyll using Lagom theme
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-xxxx-x']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>